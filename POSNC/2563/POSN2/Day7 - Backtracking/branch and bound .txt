ใน knapsack problem นี้สามารถแก้ปัญหาได้โดยการใช้ backtracking  ในการหาผลรวมของ value ที่มากที่สุด และ ตัดกรณีที่  weight เกินค่าที่เรากำหนดออกไปในระหว่างการ recursion ซึ่งพบว่าสามารถตัดกรณีที่ไม่ถูกออกไปได้มากพอสมควร

อย่างไรก็ตาม เราสามารถตัดกรณีที่ไม่ถูกต้องเพิ่มได้อีกโดยการใช้ branch and bound ซึ่งเป็นการหาค่าขอบเขตของ value
	สมมติเราได้ solution หนึ่งของการ recursion คือ v0 ซึ่งตรงตามเงื่อนไข (weight<k)
สำหรับการ recursion ใดๆ ที่ยังทำงานไม่ถึง base case และ upper bound value ของ การ recursion นั้นมีค่าน้อยกว่า v0 
จะสรุปได้ว่า ไม่ว่าจะบวกค่า value ที่เหลือของการ recursion นั้นยังไง ก็มีค่าน้อยกว่า v0  เสมอ
ทำให้เราสามารถตัดกรณีที่เหลือสำหรับการ recursion ดังกล่าวออกไปได้ทั้งหมด ซึ่งช่วยเพิ่มประสิทธิภาพในการทำงานได้

	อย่างไรก็ตามการใช้ branch and bound จะมีประสิทธิภาพน้อยเมื่อ การ recursion ที่มี upper bound value  น้อยกว่า v0 อยู่ในลำดับหลังๆ
จะทำให้สามารถตัดกรณีออกไปได้ไม่มากนัก 
	หรือ สมมติ solution สำหรับการทำงานของ recursion ในลำดับที่ i แทนด้วย r(i)
  ถ้า r(i) < r(i+1) สำหรับทุก i ที่อยู่ใน {1,2,3,...,2^n - 1} เมื่อ n คือจำนวนของสิ่งของ แล้ว
จะทำให้ไม่สามารถตัดกรณีใดๆจากการใช้ branch and bound ทิ้งออกไปได้เลย เพราะ solution มีการเพิ่มขึ้นเสมอไม่สามารถใช้ขอบเขตบนในการพิจารณาได้